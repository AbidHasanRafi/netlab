## GraphQL Schema

GraphQL স্কিমা হলো একটি খুবই গুরুত্বপূর্ণ অংশ যেটি GraphQL API-কে পরিচালনা করে এবং এটি সার্ভারের ডেটা কাঠামো নির্ধারণ করে। স্কিমা হলো GraphQL-এর মূল স্তম্ভ, যেখানে API-র ডেটা টাইপ এবং কুয়েরি অপারেশনগুলো (যেমন: ডেটা পড়া, পরিবর্তন করা) সঠিকভাবে ডিফাইন করা থাকে। এটি ক্লায়েন্ট এবং সার্ভার মধ্যে যোগাযোগের নিয়মাবলী সংজ্ঞায়িত করে।

একটি GraphQL স্কিমা মূলত Types, Queries, Mutations, Resolvers, এবং Subscriptions এর সমন্বয়ে গঠিত।

চলুন, একে একে এগুলো সম্পর্কে বিস্তারিত আলোচনা করি।


### ১. GraphQL স্কিমার মূল উপাদানসমূহ

#### Types (টাইপস)

GraphQL-এ টাইপস হলো ডেটার কাঠামো বা Data Models। টাইপস বিভিন্ন ধরনের হতে পারে, যেমন Object Types, Scalar Types, Enum Types, Interface Types এবং Union Types। এগুলোর মাধ্যমে আমরা API-তে কোন ধরনের ডেটা থাকবে এবং কীভাবে সেটি গঠিত হবে তা নির্ধারণ করি।

##### Scalar Types (স্কেলার টাইপস)
স্কেলার টাইপস হলো সাধারণ ডেটা টাইপ যা একক মান ধারণ করে, যেমন:
- `String` – একটি টেক্সট মান (যেমন: "Hello World")
- `Int` – একটি পূর্ণসংখ্যা মান (যেমন: 25)
- `Float` – একটি দশমিক সংখ্যা (যেমন: 10.5)
- `Boolean` – সত্য অথবা মিথ্যা মান (যেমন: `true` বা `false`)
- `ID` – একটি ইউনিক আইডি, সাধারণত রেকর্ডের অনন্য শনাক্তকারী হিসেবে ব্যবহৃত হয়।

##### Object Types (অবজেক্ট টাইপস)
অবজেক্ট টাইপস হলো কাস্টম ডেটা টাইপ যা একাধিক ফিল্ড ধারণ করতে পারে। প্রতিটি ফিল্ডে একটি স্কেলার টাইপ অথবা অন্য কোনো অবজেক্ট টাইপ থাকতে পারে। উদাহরণস্বরূপ:

```graphql
type Book {
  title: String
  author: String
  publishedYear: Int
}
```

এখানে, `Book` টাইপের তিনটি ফিল্ড রয়েছে: `title`, `author`, এবং `publishedYear`, যেগুলো স্কেলার টাইপ (String, Int) এর মান ধারণ করে।

##### Enum Types (এনাম টাইপস)
এনাম টাইপস হলো একটি কাস্টম ডেটা টাইপ যা একটি নির্দিষ্ট সেটের মধ্যে সীমাবদ্ধ থাকে। উদাহরণস্বরূপ, যদি আপনি কোন ডেটা টাইপের মধ্যে সীমাবদ্ধ মান চাচ্ছেন, তবে আপনি একটি Enum ব্যবহার করবেন।

```graphql
enum Genre {
  FICTION
  NON_FICTION
  MYSTERY
  FANTASY
}
```

এখানে, `Genre` একটি Enum টাইপ, যার ভ্যালু হবে `FICTION`, `NON_FICTION`, `MYSTERY`, অথবা `FANTASY`।

##### Interface Types (ইন্টারফেস টাইপস)
ইন্টারফেস টাইপস এমন একটি কনসেপ্ট যেখানে আপনি একটি সাধারণ কাঠামো তৈরি করতে পারেন, যা অন্যান্য টাইপগুলো দ্বারা ইমপ্লিমেন্ট করা যায়।

```graphql
interface Character {
  name: String
  age: Int
}
```

এখানে, `Character` একটি ইন্টারফেস, এবং অন্য টাইপ যেমন `Author`, `Actor` ইত্যাদি এটি ইমপ্লিমেন্ট করতে পারে।

##### Union Types (ইউনিয়ন টাইপস)
ইউনিয়ন টাইপ হলো এমন একটি টাইপ যা বিভিন্ন টাইপের মধ্যে যেকোনো একটিকে গ্রহণ করতে পারে। এটি তখনই ব্যবহৃত হয় যখন আপনি বিভিন্ন টাইপের মধ্যে যেকোনো একটিকে রিটার্ন করতে চান।

```graphql
union SearchResult = Book | Author
```

এখানে, `SearchResult` একটি ইউনিয়ন টাইপ যা হয়তো `Book` অথবা `Author` টাইপ রিটার্ন করতে পারে।


#### ২. Queries (কুয়েরি)

GraphQL-এর Query হলো একটি রিকোয়েস্ট যার মাধ্যমে ক্লায়েন্ট সার্ভারের কাছে ডেটা ফেচ করে। Query-এর মধ্যে আমরা যে ফিল্ডগুলির জন্য ডেটা চাই, তা নির্দিষ্ট করে দেই।

##### Query-র উদাহরণ:

```graphql
type Query {
  books: [Book]
  book(id: ID!): Book
}
```

এখানে, `books` কুয়েরি একটি `Book` টাইপের অ্যারে রিটার্ন করবে, এবং `book(id: ID!)` কুয়েরি নির্দিষ্ট একটি বইয়ের তথ্য ফিরিয়ে দেবে যার `id` দেওয়া থাকবে।

একটি কুয়েরি পাঠানোর উদাহরণ:

```graphql
{
  books {
    title
    author
  }
}
```

এই কুয়েরি সার্ভারের কাছে `books` রিসোর্সের `title` এবং `author` ফিল্ড চাইবে।


#### ৩. Mutations (মিউটেশন)

GraphQL-এ Mutation ব্যবহার করা হয় ডেটা পরিবর্তন করার জন্য। অর্থাৎ, যখন আপনি ডেটা তৈরি, আপডেট বা ডিলিট করতে চান, তখন আপনি মিউটেশন ব্যবহার করবেন। Mutation ঠিক কুয়েরির মতোই কাজ করে, কিন্তু তার উদ্দেশ্য হচ্ছে ডেটার পরিবর্তন।

##### Mutation-র উদাহরণ:

```graphql
type Mutation {
  addBook(title: String!, author: String!): Book
  updateBook(id: ID!, title: String, author: String): Book
}
```

এখানে, `addBook` একটি নতুন বই তৈরি করবে এবং `updateBook` বিদ্যমান বইয়ের তথ্য আপডেট করবে।

একটি Mutation পাঠানোর উদাহরণ:

```graphql
mutation {
  addBook(title: "The Catcher in the Rye", author: "J.D. Salinger") {
    title
    author
  }
}
```

এই মিউটেশনটি একটি নতুন বই যোগ করবে এবং তার শিরোনাম ও লেখক ফিরিয়ে দেবে।


#### ৪. Resolvers (রেজলভার)

Resolvers হলো সেই ফাংশনগুলো যা কুয়েরি এবং মিউটেশনের জন্য ডেটা সরবরাহ করে। যখন আপনি কুয়েরি পাঠান, তখন সার্ভার রেজলভার ব্যবহার করে সেই কুয়েরি সম্পর্কিত ডেটা বের করে এনে রিটার্ন করে।

##### Resolvers-র উদাহরণ:

```javascript
const resolvers = {
  Query: {
    books: () => booksData, // বইয়ের ডেটা ফিরিয়ে দেবে
    book: (parent, args) => booksData.find(book => book.id === args.id),
  },
  Mutation: {
    addBook: (parent, args) => {
      const newBook = { title: args.title, author: args.author };
      booksData.push(newBook);
      return newBook;
    }
  }
};
```

এখানে `books` কুয়েরি সমস্ত বইয়ের তথ্য ফিরিয়ে দিচ্ছে এবং `book(id)` কুয়েরি নির্দিষ্ট একটি বই ফিরিয়ে দিচ্ছে।


#### ৫. Subscriptions (সাবস্ক্রিপশন)

GraphQL Subscription রিয়েল-টাইম ডেটা ফেচ করার জন্য ব্যবহৃত হয়। যখন ডেটা কোনো পরিবর্তন হয়, তখন Subscription ক্লায়েন্টকে তা জানিয়ে দেয়। উদাহরণস্বরূপ, আপনি একটি চ্যাট অ্যাপ্লিকেশন তৈরি করতে চাইলে এটি খুবই সহায়ক হতে পারে।

##### Subscription-র উদাহরণ:

```graphql
type Subscription {
  newBookAdded: Book
}
```

এখানে, যখনই কোনো নতুন বই যোগ হবে, তখন newBookAdded সাবস্ক্রিপশন রিয়েল-টাইমে সেই বইটির তথ্য ক্লায়েন্টকে পাঠিয়ে দিবে।



GraphQL স্কিমা হলো API ডিজাইন করার একটি শক্তিশালী এবং নমনীয় পদ্ধতি। স্কিমা ব্যবহারের মাধ্যমে ডেটার কাঠামো সঠিকভাবে নির্ধারণ করা হয়, এবং ক্লায়েন্ট ও সার্ভারের মধ্যে যোগাযোগ সুসংগঠিত ও নিয়মিত হয়। Query, Mutation, Resolvers, এবং Subscriptions—এই সব উপাদান একত্রে কাজ করে একটি শক্তিশালী API তৈরি করতে সাহায্য করে। 

GraphQL-এর স্কিমা আপনাকে ডেটার কাঠামোকে স্বচ্ছ, কাস্টমাইজেবল এবং সহজে মেইনটেইনযোগ্য করে তোলে, যা দীর্ঘমেয়াদী প্রজেক্টে খুবই সহায়ক।